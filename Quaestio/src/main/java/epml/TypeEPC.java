/*
 * Copyright Â© 2009-2018 The Apromore Initiative.
 *
 * This file is part of "Apromore".
 *
 * "Apromore" is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3 of the
 * License, or (at your option) any later version.
 *
 * "Apromore" is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program.
 * If not, see <http://www.gnu.org/licenses/lgpl-3.0.html>.
 */
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.3 in JDK 1.6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2009.09.15 at 04:54:36 PM EST 
//

package epml;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;

import org.w3c.dom.Element;

//import com.processconfiguration.cmap.CORType;

/**
 * <p>
 * Java class for typeEPC complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="typeEPC">
 *   &lt;complexContent>
 *     &lt;extension base="{http://www.epml.de}tExtensibleElements">
 *       &lt;sequence>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element name="configurationRequirement" type="{http://www.epml.de}typeCReq"/>
 *           &lt;element name="configurationGuideline" type="{http://www.epml.de}typeCReq"/>
 *           &lt;element name="configurationOrder" type="{http://www.epml.de}typeCOrder"/>
 *         &lt;/choice>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element name="event" type="{http://www.epml.de}typeEvent" minOccurs="0"/>
 *           &lt;element name="function" type="{http://www.epml.de}typeFunction" minOccurs="0"/>
 *           &lt;element name="role" type="{http://www.epml.de}typeRole" minOccurs="0"/>
 *           &lt;element name="object" type="{http://www.epml.de}typeObject" minOccurs="0"/>
 *           &lt;element name="processInterface" type="{http://www.epml.de}typeProcessInterface" minOccurs="0"/>
 *           &lt;element name="and" type="{http://www.epml.de}typeAND" minOccurs="0"/>
 *           &lt;element name="or" type="{http://www.epml.de}typeOR" minOccurs="0"/>
 *           &lt;element name="xor" type="{http://www.epml.de}typeXOR" minOccurs="0"/>
 *           &lt;element name="range" type="{http://www.epml.de}typeRANGE" minOccurs="0"/>
 *           &lt;element name="arc" type="{http://www.epml.de}typeArc" minOccurs="0"/>
 *           &lt;any/>
 *         &lt;/choice>
 *       &lt;/sequence>
 *       &lt;attribute name="epcId" use="required" type="{http://www.w3.org/2001/XMLSchema}positiveInteger" />
 *       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "typeEPC", propOrder = {
		"configurationRequirementOrConfigurationGuidelineOrConfigurationOrder",
		"eventOrFunctionOrRole", "arc", "event", "xor", "and", "or", "object",
		"role", "function" })
public class TypeEPC extends TExtensibleElements {

	public static final String TypeXOR = null;
	@XmlElementRefs({
			@XmlElementRef(name = "configurationGuideline", type = JAXBElement.class),
			@XmlElementRef(name = "configurationOrder", type = JAXBElement.class),
			@XmlElementRef(name = "configurationRequirement", type = JAXBElement.class) })
	protected List<JAXBElement<?>> configurationRequirementOrConfigurationGuidelineOrConfigurationOrder;
	@XmlAnyElement(lax = true)
	protected List<Object> eventOrFunctionOrRole;
	@XmlAttribute(required = true)
	@XmlSchemaType(name = "positiveInteger")
	protected BigInteger epcId;
	@XmlAttribute(required = true)
	protected String name;
	// added
	protected List<TypeFunction> function;
	protected List<TypeEvent> event;
	protected List<TypeRole> role;
	protected List<TypeObject> object;
	protected List<TypeArc> arc;
	protected List<TypeOR> or;
	protected List<TypeAND> and;
	protected List<TypeXOR> xor;

	/**
	 * Gets the value of the
	 * configurationRequirementOrConfigurationGuidelineOrConfigurationOrder
	 * property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the
	 * configurationRequirementOrConfigurationGuidelineOrConfigurationOrder
	 * property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getConfigurationRequirementOrConfigurationGuidelineOrConfigurationOrder().add(
	 * 		newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link JAXBElement }{@code <}{@link TypeCReq }{@code >} {@link JAXBElement }
	 * {@code <}{@link TypeCReq }{@code >} {@link JAXBElement }{@code <}
	 * {@link TypeCOrder }{@code >}
	 * 
	 * 
	 */
	public List<JAXBElement<?>> getConfigurationRequirementOrConfigurationGuidelineOrConfigurationOrder() {
		if (configurationRequirementOrConfigurationGuidelineOrConfigurationOrder == null) {
			configurationRequirementOrConfigurationGuidelineOrConfigurationOrder = new ArrayList<JAXBElement<?>>();
		}
		return this.configurationRequirementOrConfigurationGuidelineOrConfigurationOrder;
	}

	/**
	 * Gets the value of the eventOrFunctionOrRole property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the eventOrFunctionOrRole property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getEventOrFunctionOrRole().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link JAXBElement }{@code <}{@link TypeRANGE }{@code >}
	 * {@link JAXBElement }{@code <}{@link TypeArc }{@code >} {@link JAXBElement }
	 * {@code <}{@link TypeAND }{@code >} {@link JAXBElement }{@code <}
	 * {@link TypeOR }{@code >} {@link JAXBElement }{@code <}{@link TypeRole }
	 * {@code >} {@link JAXBElement }{@code <}{@link TypeObject }{@code >}
	 * {@link JAXBElement }{@code <}{@link TypeFunction }{@code >} {@link Object }
	 * {@link Element } {@link JAXBElement }{@code <}{@link TypeXOR }{@code >}
	 * {@link JAXBElement }{@code <}{@link TypeProcessInterface }{@code >}
	 * {@link JAXBElement }{@code <}{@link TypeEvent }{@code >}
	 * 
	 * 
	 */
	public List<Object> getEventOrFunctionOrRole() {
		if (eventOrFunctionOrRole == null) {
			eventOrFunctionOrRole = new ArrayList<Object>();
		}
		return this.eventOrFunctionOrRole;
	}

	public List<TypeFunction> getFunctions() {
		if (function == null) {
			function = new ArrayList<TypeFunction>();
			initializeLists();
		}
		return this.function;
	}

	public List<TypeEvent> getEvents() {
		if (event == null) {
			event = new ArrayList<TypeEvent>();
			initializeLists();
		}
		return this.event;
	}

	public List<TypeArc> getArcs() {
		if (arc == null) {
			arc = new ArrayList<TypeArc>();
			initializeLists();
		}
		return this.arc;
	}

	public List<TypeRole> getRoles() {
		if (role == null) {
			role = new ArrayList<TypeRole>();
			initializeLists();
		}
		return this.role;
	}

	public List<TypeObject> getObjects() {
		if (object == null) {
			object = new ArrayList<TypeObject>();
			initializeLists();
		}
		return this.object;
	}

	// ----- Add methods for OR,AND,XOR
	public List<TypeOR> getOR() {
		if (or == null) {
			or = new ArrayList<TypeOR>();
			initializeLists();
		}
		return this.or;
	}

	public List<TypeAND> getAND() {
		if (and == null) {
			and = new ArrayList<TypeAND>();
			initializeLists();
		}
		return this.and;
	}

	public List<TypeXOR> getXOR() {
		if (xor == null) {
			xor = new ArrayList<TypeXOR>();
			initializeLists();
		}
		return this.xor;
	}

	// ------ End new methods

	public void initializeLists() {
		/*
		 * function = new ArrayList<TypeFunction>(); event = new
		 * ArrayList<TypeEvent>(); arc = new ArrayList<TypeArc>(); role = new
		 * ArrayList<TypeRole>(); object = new ArrayList<TypeObject>(); or = new
		 * ArrayList<TypeOR>(); and = new ArrayList<TypeAND>(); xor = new
		 * ArrayList<TypeXOR>();
		 */
		for (Object current : getEventOrFunctionOrRole()) {
			Object o = ((JAXBElement) current).getValue();
			if (o instanceof TypeFunction) {
				function.add((TypeFunction) o);
			} else if (o instanceof TypeEvent) {
				event.add((TypeEvent) o);
			} else if (o instanceof TypeArc) {
				arc.add((TypeArc) o);
			} else if (o instanceof TypeRole) {
				role.add((TypeRole) o);
			} else if (o instanceof TypeObject) {
				object.add((TypeObject) o);
			} else if (o instanceof TypeOR) {
				or.add((TypeOR) o);
			} else if (o instanceof TypeAND) {
				and.add((TypeAND) o);
			} else if (o instanceof TypeXOR) {
				xor.add((TypeXOR) o);
			}
		}
	}

	/**
	 * Gets the value of the epcId property.
	 * 
	 * @return possible object is {@link BigInteger }
	 * 
	 */
	public BigInteger getEpcId() {
		return epcId;
	}

	/**
	 * Sets the value of the epcId property.
	 * 
	 * @param value
	 *            allowed object is {@link BigInteger }
	 * 
	 */
	public void setEpcId(BigInteger value) {
		this.epcId = value;
	}

	/**
	 * Gets the value of the name property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getName() {
		return name;
	}

	/**
	 * Sets the value of the name property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setName(String value) {
		this.name = value;
	}

}
